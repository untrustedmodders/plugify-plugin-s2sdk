#include <keyvalues.h>

PLUGIFY_WARN_PUSH()

#if defined(__clang)
PLUGIFY_WARN_IGNORE("-Wreturn-type-c-linkage")
#elif defined(_MSC_VER)
PLUGIFY_WARN_IGNORE(4190)
#endif

/**
 * @brief Creates a new KeyValues instance
 *
 * @param setName The name to assign to this KeyValues instance
 * @return Pointer to the newly created KeyValues object
 *
 * @note The caller is responsible for destroying the returned KeyValues
 *       object using Kv1Destroy() to prevent memory leaks.
 */
extern "C" PLUGIN_API KeyValues* Kv1Create(const plg::string& setName) {
	return new KeyValues(setName.c_str());
}

/**
 * @brief Destroys a KeyValues instance
 *
 * Deletes the KeyValues object and all its child nodes recursively.
 *
 * @param kv Pointer to the KeyValues object to destroy
 *
 * @note After calling this function, the pointer becomes invalid and
 *       should not be used.
 */
extern "C" PLUGIN_API void Kv1Destroy(KeyValues* kv) {
	delete kv;
}

/**
 * @brief Gets the section name of a KeyValues instance
 *
 * @param kv Pointer to the KeyValues object
 * @return The name of the KeyValues section
 */
extern "C" PLUGIN_API plg::string Kv1GetName(KeyValues* kv) {
	return kv->GetName();
}

/**
 * @brief Sets the section name of a KeyValues instance
 *
 * @param kv Pointer to the KeyValues object
 * @param name The new name to assign to this KeyValues section
 */
extern "C" PLUGIN_API void Kv1SetName(KeyValues* kv, const plg::string& name) {
	kv->SetName(name.c_str());
}

/**
 * @brief Finds a key by name
 *
 * Searches for a subkey with the specified name.
 *
 * @param kv Pointer to the KeyValues object to search in
 * @param keyName The name of the key to find
 * @return Pointer to the found KeyValues subkey, or NULL if not found
 */
extern "C" PLUGIN_API KeyValues* Kv1FindKey(KeyValues* kv, const plg::string& keyName) {
	return kv->FindKey(keyName.c_str());
}

/**
 * @brief Finds a key by name or creates it if it doesn't exist
 *
 * Searches for a subkey with the specified name. If the key is not found,
 * creates a new key with that name.
 *
 * @param kv Pointer to the KeyValues object to search in
 * @param keyName The name of the key to find or create
 * @return Pointer to the found or newly created KeyValues subkey (never NULL)
 */
extern "C" PLUGIN_API KeyValues* Kv1FindKeyOrCreate(KeyValues* kv, const plg::string& keyName) {
	return kv->FindKey(keyName.c_str(), true);
}

/**
 * @brief Creates a new subkey with the specified name
 *
 * Creates a new key as a child of the current KeyValues object.
 *
 * @param kv Pointer to the parent KeyValues object
 * @param keyName The name for the new key
 * @return Pointer to the newly created KeyValues subkey
 */
extern "C" PLUGIN_API KeyValues* Kv1CreateKey(KeyValues* kv, const plg::string& keyName) {
	return kv->CreatePeerKey(keyName.c_str());
}

/**
 * @brief Creates a new subkey with an autogenerated name
 *
 * Creates a new key with an autogenerated integer name. The name is
 * guaranteed to be an integer value 1 higher than the highest other
 * integer key name.
 *
 * @param kv Pointer to the parent KeyValues object
 * @return Pointer to the newly created KeyValues subkey
 */
extern "C" PLUGIN_API KeyValues* Kv1CreateNewKey(KeyValues* kv) {
	return kv->CreateNewKey();
}

/**
 * @brief Adds a subkey to this KeyValues instance
 *
 * Adds an existing KeyValues object as a child of the current KeyValues.
 *
 * @param kv Pointer to the parent KeyValues object
 * @param subKey Pointer to the KeyValues object to add as a child
 *
 * @warning Make sure the subKey isn't already a child of some other
 *          KeyValues object to avoid corruption of the tree structure.
 */
extern "C" PLUGIN_API void Kv1AddSubKey(KeyValues* kv, KeyValues* subKey) {
	kv->AddSubKey(subKey);
}

/**
 * @brief Gets the first subkey in the list
 *
 * Returns the first child key in this KeyValues instance. Use Kv1GetNextKey()
 * to iterate through all children.
 *
 * @param kv Pointer to the parent KeyValues object
 * @return Pointer to the first subkey, or NULL if there are no children
 *
 * @note This function iterates over both keys AND values. Use GetFirstTrueSubKey()
 *       in the C++ API if you need to iterate only over keys that have children.
 */
extern "C" PLUGIN_API KeyValues* Kv1GetFirstSubKey(KeyValues* kv) {
	return kv->GetFirstSubKey();
}

/**
 * @brief Gets the next sibling key in the list
 *
 * Returns the next peer key at the same level in the tree structure.
 *
 * @param kv Pointer to the current KeyValues object
 * @return Pointer to the next sibling key, or NULL if this is the last sibling
 *
 * @note Use this in combination with Kv1GetFirstSubKey() to iterate through
 *       all children of a parent key.
 */
extern "C" PLUGIN_API KeyValues* Kv1GetNextKey(KeyValues* kv) {
	return kv->GetNextKey();
}

/**
 * @brief Gets a color value from a key
 *
 * Retrieves a color value associated with the specified key name.
 *
 * @param kv Pointer to the KeyValues object
 * @param keyName The name of the key to retrieve the color from
 * @param defaultValue The default color value to return if the key is not found
 * @return The color value as a 32-bit integer (RGBA)
 */
extern "C" PLUGIN_API int Kv1GetColor(KeyValues* kv, const plg::string& keyName, int defaultValue) {
	Color color = kv->GetColor(keyName.c_str(), *reinterpret_cast<Color*>(&defaultValue));
	return *reinterpret_cast<const int*>(&color);
}

/**
 * @brief Sets a color value for a key
 *
 * Sets the color value for the specified key name.
 *
 * @param kv Pointer to the KeyValues object
 * @param keyName The name of the key to set the color for
 * @param value The color value as a 32-bit integer (RGBA)
 */
extern "C" PLUGIN_API void Kv1SetColor(KeyValues* kv, const plg::string& keyName, int value) {
	kv->SetColor(keyName.c_str(), *reinterpret_cast<Color*>(&value));
}

/**
 * @brief Gets an integer value from a key
 *
 * Retrieves an integer value associated with the specified key name.
 *
 * @param kv Pointer to the KeyValues object
 * @param keyName The name of the key to retrieve the integer from
 * @param defaultValue The default value to return if the key is not found
 * @return The integer value associated with the key, or defaultValue if not found
 */
extern "C" PLUGIN_API int Kv1GetInt(KeyValues* kv, const plg::string& keyName, int defaultValue) {
	return kv->GetInt(keyName.c_str(), defaultValue);
}

/**
 * @brief Sets an integer value for a key
 *
 * Sets the integer value for the specified key name.
 *
 * @param kv Pointer to the KeyValues object
 * @param keyName The name of the key to set the integer for
 * @param value The integer value to set
 */
extern "C" PLUGIN_API void Kv1SetInt(KeyValues* kv, const plg::string& keyName, int value) {
	kv->SetInt(keyName.c_str(), value);
}

/**
 * @brief Gets a float value from a key
 *
 * Retrieves a floating-point value associated with the specified key name.
 *
 * @param kv Pointer to the KeyValues object
 * @param keyName The name of the key to retrieve the float from
 * @param defaultValue The default value to return if the key is not found
 * @return The float value associated with the key, or defaultValue if not found
 */
extern "C" PLUGIN_API float Kv1GetFloat(KeyValues* kv, const plg::string& keyName, float defaultValue) {
	return kv->GetFloat(keyName.c_str(), defaultValue);
}

/**
 * @brief Sets a float value for a key
 *
 * Sets the floating-point value for the specified key name.
 *
 * @param kv Pointer to the KeyValues object
 * @param keyName The name of the key to set the float for
 * @param value The float value to set
 */
extern "C" PLUGIN_API void Kv1SetFloat(KeyValues* kv, const plg::string& keyName, float value) {
	kv->SetFloat(keyName.c_str(), value);
}

/**
 * @brief Gets a string value from a key
 *
 * Retrieves a string value associated with the specified key name.
 *
 * @param kv Pointer to the KeyValues object
 * @param keyName The name of the key to retrieve the string from
 * @param defaultValue The default string to return if the key is not found
 * @return The string value associated with the key, or defaultValue if not found
 */
extern "C" PLUGIN_API plg::string Kv1GetString(KeyValues* kv, const plg::string& keyName, const plg::string& defaultValue) {
	return kv->GetString(keyName.c_str(), defaultValue.c_str());
}

/**
 * @brief Sets a string value for a key
 *
 * Sets the string value for the specified key name.
 *
 * @param kv Pointer to the KeyValues object
 * @param keyName The name of the key to set the string for
 * @param value The string value to set
 */
extern "C" PLUGIN_API void Kv1SetString(KeyValues* kv, const plg::string& keyName, const plg::string& value) {
	kv->SetString(keyName.c_str(), value.c_str());
}

/**
 * @brief Gets a pointer value from a key
 *
 * Retrieves a void pointer value associated with the specified key name.
 *
 * @param kv Pointer to the KeyValues object
 * @param keyName The name of the key to retrieve the pointer from
 * @param defaultValue The default pointer to return if the key is not found
 * @return The pointer value associated with the key, or defaultValue if not found
 */
extern "C" PLUGIN_API void* Kv1GetPtr(KeyValues* kv, const plg::string& keyName, void* defaultValue) {
	return kv->GetPtr(keyName.c_str(), defaultValue);
}

/**
 * @brief Sets a pointer value for a key
 *
 * Sets the void pointer value for the specified key name.
 *
 * @param kv Pointer to the KeyValues object
 * @param keyName The name of the key to set the pointer for
 * @param value The pointer value to set
 */
extern "C" PLUGIN_API void Kv1SetPtr(KeyValues* kv, const plg::string& keyName, void* value) {
	kv->SetPtr(keyName.c_str(), value);
}

/**
 * @brief Gets a boolean value from a key
 *
 * Retrieves a boolean value associated with the specified key name.
 *
 * @param kv Pointer to the KeyValues object
 * @param keyName The name of the key to retrieve the boolean from
 * @param defaultValue The default value to return if the key is not found
 * @return The boolean value associated with the key, or defaultValue if not found
 */
extern "C" PLUGIN_API bool Kv1GetBool(KeyValues* kv, const plg::string& keyName, bool defaultValue) {
	return kv->GetBool(keyName.c_str(), defaultValue);
}

/**
 * @brief Sets a boolean value for a key
 *
 * Sets the boolean value for the specified key name.
 *
 * @param kv Pointer to the KeyValues object
 * @param keyName The name of the key to set the boolean for
 * @param value The boolean value to set
 */
extern "C" PLUGIN_API void Kv1SetBool(KeyValues* kv, const plg::string& keyName, bool value) {
	kv->SetBool(keyName.c_str(), value);
}

/**
 * @brief Makes a deep copy of a KeyValues tree
 *
 * Creates a new KeyValues instance that is a complete copy of the source,
 * including all subkeys recursively.
 *
 * @param kv Pointer to the KeyValues object to copy
 * @return Pointer to the newly allocated copy of the KeyValues tree
 *
 * @note The caller is responsible for destroying the returned copy
 *       using Kv1Destroy() to prevent memory leaks.
 */
extern "C" PLUGIN_API KeyValues* Kv1MakeCopy(KeyValues* kv) {
	return kv->MakeCopy();
}

/**
 * @brief Clears all subkeys and the current value
 *
 * Removes and deletes all child keys and resets the value of this KeyValues
 * instance. The KeyValues object itself remains valid but empty.
 *
 * @param kv Pointer to the KeyValues object to clear
 */
extern "C" PLUGIN_API void Kv1Clear(KeyValues* kv) {
	kv->Clear();
}

/**
 * @brief Checks if a key exists and has no value or subkeys
 *
 * Determines whether the specified key exists but is empty (has no value
 * and no child keys).
 *
 * @param kv Pointer to the KeyValues object
 * @param keyName The name of the key to check
 * @return true if the key exists and is empty, false otherwise
 */
extern "C" PLUGIN_API bool Kv1IsEmpty(KeyValues* kv, const plg::string& keyName) {
	return kv->IsEmpty(keyName.c_str());
}


PLUGIFY_WARN_POP()