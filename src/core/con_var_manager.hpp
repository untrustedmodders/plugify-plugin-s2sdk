#pragma once

#include "listener_manager.hpp"

#include <convar.h>
#include <icvar.h>

using ConVarChangeListenerCallback = void (*)(uint64 conVarHandle, const plg::string& newValue, const plg::string& oldValue);

enum class ConVarFlag : uint64_t {
	None = 0, // The default, no flags at all
				  
	// Command to ConVars and ConCommands
	LinkedConcommand = (1 << 0),
	DevelopmentOnly = (1 << 1),      // Hidden in released products. Flag is removed automatically if ALLOW_DEVELOPMENT_CVARS is defined.
	GameDll = (1 << 2),              // defined by the game DLL
	ClientDll = (1 << 3),            // defined by the client DLL
	Hidden = (1 << 4),               // Hidden. Doesn't appear in find or auto complete. Like DEVELOPMENTONLY, but can't be compiled out.

	// ConVar only
	Protected = (1 << 5),            // It's a server cvar, but we don't send the data since it's a password, etc. Sends 1 if it's not blank/zero, 0 otherwise as value
	SpOnly = (1 << 6),               // This cvar cannot be changed by clients connected to a multiplayer server.
	Archive = (1 << 7),              // set to cause it to be saved to vars.rc
	Notify = (1 << 8),               // notifies players when changed
	UserInfo = (1 << 9),             // changes the client's info string

	Missing0 = (1 << 10),            // Something that hides the cvar from the cvar lookups
	Unlogged = (1 << 11),            // If this is a _SERVER, don't log changes to the log file / console if we are creating a log
	Missing1 = (1 << 12),            // Something that hides the cvar from the cvar lookups

	Replicated = (1 << 13),          // server setting enforced on clients, TODO rename to FCAR_SERVER at some time
	Cheat = (1 << 14),               // Only usable in singleplayer / debug / multiplayer & sv_cheats
	PerUser = (1 << 15),             // causes varnameN where N == 2 through max splitscreen slots for mod to be autogenerated
	Demo = (1 << 16),                // record this cvar when starting a demo file
	DontRecord = (1 << 17),          // don't record these commands in demofiles
	Missing2 = (1 << 18),
	Release = (1 << 19),             // Cvars tagged with this are the only cvars available to customers
	MenuBarItem = (1 << 20),
	Missing3 = (1 << 21),

	NotConnected = (1 << 22),        // cvar cannot be changed by a client that is connected to a server
	VconsoleFuzzyMatching = (1 << 23),

	ServerCanExecute = (1 << 24),    // the server is allowed to execute this command on clients via ClientCommand/NET_StringCmd/CBaseClientState::ProcessStringCmd.
	ClientCanExecute = (1 << 25),    // Assigned to commands to let clients execute them
	ServerCannotQuery = (1 << 26),   // If this is set, then the server is not allowed to query this cvar's value (via IServerPluginHelpers::StartQueryCvarValue).
	VconsoleSetFocus = (1 << 27),
	ClientCmdCanExecute = (1 << 28), // IVEngineClient::ClientCmd is allowed to execute this command.
									 // Note: IVEngineClient::ClientCmd_Unrestricted can run any client command.
	ExecutePerTick = (1 << 29)
};

struct ConVarInfo {
	explicit ConVarInfo(plg::string name, plg::string description = {});
	~ConVarInfo() = default;

	plg::string name;
	plg::string description;
	std::unique_ptr<ConVarRef> conVar;
	ListenerManager<ConVarChangeListenerCallback> hook;
};

class ConVarManager;
extern ConVarManager g_ConVarManager;

class ConVarManager {
public:
	ConVarManager() = default;
	~ConVarManager();

	static void Init();

	template<typename T>
	ConVarRef CreateConVar(const plg::string& name, const plg::string& description, const T& defaultVal, ConVarFlag flags, bool hasMin = false, T min = {}, bool hasMax = {}, T max = {}) {
		if (name.empty() || g_pCVar->FindConVar(name.c_str()).IsValidRef()) {
			plg::print(LS_DETAILED, "[ConVarManager::CreateConVar]: ConVar '{}' is empty or already exists\n", name);
			return {};
		}

		auto it = m_cnvLookup.find(name);
		if (it != m_cnvLookup.end()) {
			return *it->second->conVar;
		}

		auto flgs = static_cast<uint64>(flags);
		if (flgs == FCVAR_NONE) {
			flgs |= ConVar_GetDefaultFlags();
		}

		auto& conVarInfo = *m_cnvLookup.emplace(name, std::make_unique<ConVarInfo>(name, description)).first->second;
		auto conVar = std::make_unique<ConVarRef>(name.c_str());
		if (conVar->IsValidRef()) {
			conVarInfo.conVar = std::move(conVar);
		} else {
			conVarInfo.conVar = std::unique_ptr<ConVarRef>(new CConVar<T>(conVarInfo.name.c_str(), SanitiseConVarFlags(flgs), conVarInfo.description.c_str(), defaultVal, hasMin, min, hasMax, max));
		}
		return *conVarInfo.conVar;
	}

	template<typename T>
	ConVarRef FindConVar(const plg::string& name) {
		auto it = m_cnvLookup.find(name);
		if (it != m_cnvLookup.end()) {
			return *it->second->conVar;
		}

		auto& conVarInfo = *m_cnvLookup.emplace(name, std::make_unique<ConVarInfo>(name, "")).first->second;
		conVarInfo.conVar = std::make_unique<CConVarRef<T>>(name.c_str());

		if (!conVarInfo.conVar->IsValidRef()) {
			plg::print(LS_WARNING, "Failed to find \"{}\" convar\n", name);
			return {};
		}

		return *conVarInfo.conVar;
	}

	ConVarRef FindConVar(const plg::string& name);
	bool RemoveConVar(const plg::string& name);

	bool HookConVarChange(const plg::string& name, ConVarChangeListenerCallback callback);
	bool UnhookConVarChange(const plg::string& name, ConVarChangeListenerCallback callback);

	static void ChangeDefault(
		ConVarRefAbstract* ref,
		CSplitScreenSlot slot,
		const char* newValue,
		const char* oldValue,
		void*
	);

	static void ChangeGlobal(
		ConVarRefAbstract* ref,
		CSplitScreenSlot slot,
		const char* newValue,
		const char* oldValue,
		void*
	);

	static bool AutoExecConfig(
	    std::span<const uint64> conVarHandles,
	    bool autoCreate,
	    std::string_view name,
	    std::string_view folder
	);

private:
	static void UpdateConVarValue(ConVarRefAbstract conVar, std::string_view value);

private:
	plg::parallel_flat_hash_map<plg::string, std::unique_ptr<ConVarInfo>, plg::case_insensitive_hash, plg::case_insensitive_equal> m_cnvLookup;
	ListenerManager<ConVarChangeListenerCallback> m_globalCallbacks;
};

inline ConVarFlag operator|(ConVarFlag lhs, ConVarFlag rhs) noexcept {
	using underlying = std::underlying_type_t<ConVarFlag>;
	return static_cast<ConVarFlag>(static_cast<underlying>(lhs) | static_cast<underlying>(rhs));
}

inline bool operator&(ConVarFlag lhs, ConVarFlag rhs) noexcept {
	using underlying = std::underlying_type_t<ConVarFlag>;
	return static_cast<underlying>(lhs) & static_cast<underlying>(rhs);
}

inline ConVarFlag& operator|=(ConVarFlag& lhs, ConVarFlag rhs) noexcept {
	lhs = lhs | rhs;
	return lhs;
}

