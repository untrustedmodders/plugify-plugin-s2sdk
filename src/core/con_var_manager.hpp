#pragma once

#include "listener_manager.hpp"
#include <core/sdk/utils.h>

#include <convar.h>

using ConVarChangeListenerCallback = void (*)(ConVarRefAbstract conVar, const plg::string& newValue, const plg::string& oldValue);

enum ConVarFlag : int64_t {
	None = 0, // The default, no flags at all
				  
	// Command to ConVars and ConCommands
	LinkedConcommand = (1 << 0),
	DevelopmentOnly = (1 << 1),      // Hidden in released products. Flag is removed automatically if ALLOW_DEVELOPMENT_CVARS is defined.
	GameDll = (1 << 2),              // defined by the game DLL
	ClientDll = (1 << 3),            // defined by the client DLL
	Hidden = (1 << 4),               // Hidden. Doesn't appear in find or auto complete. Like DEVELOPMENTONLY, but can't be compiled out.

	// ConVar only
	Protected = (1 << 5),            // It's a server cvar, but we don't send the data since it's a password, etc. Sends 1 if it's not blank/zero, 0 otherwise as value
	SpOnly = (1 << 6),               // This cvar cannot be changed by clients connected to a multiplayer server.
	Archive = (1 << 7),              // set to cause it to be saved to vars.rc
	Notify = (1 << 8),               // notifies players when changed
	UserInfo = (1 << 9),             // changes the client's info string

	Missing0 = (1 << 10),            // Something that hides the cvar from the cvar lookups
	Unlogged = (1 << 11),            // If this is a _SERVER, don't log changes to the log file / console if we are creating a log
	Missing1 = (1 << 12),            // Something that hides the cvar from the cvar lookups

	Replicated = (1 << 13),          // server setting enforced on clients, TODO rename to FCAR_SERVER at some time
	Cheat = (1 << 14),               // Only usable in singleplayer / debug / multiplayer & sv_cheats
	PerUser = (1 << 15),             // causes varnameN where N == 2 through max splitscreen slots for mod to be autogenerated
	Demo = (1 << 16),                // record this cvar when starting a demo file
	DontRecord = (1 << 17),          // don't record these commands in demofiles
	Missing2 = (1 << 18),
	Release = (1 << 19),             // Cvars tagged with this are the only cvars available to customers
	MenuBarItem = (1 << 20),
	Missing3 = (1 << 21),

	NotConnected = (1 << 22),        // cvar cannot be changed by a client that is connected to a server
	VconsoleFuzzyMatching = (1 << 23),

	ServerCanExecute = (1 << 24),    // the server is allowed to execute this command on clients via ClientCommand/NET_StringCmd/CBaseClientState::ProcessStringCmd.
	ClientCanExecute = (1 << 25),    // Assigned to commands to let clients execute them
	ServerCannotQuery = (1 << 26),   // If this is set, then the server is not allowed to query this cvar's value (via IServerPluginHelpers::StartQueryCvarValue).
	VconsoleSetFocus = (1 << 27),
	ClientCmdCanExecute = (1 << 28), // IVEngineClient::ClientCmd is allowed to execute this command.
									 // Note: IVEngineClient::ClientCmd_Unrestricted can run any client command.
	ExecutePerTick = (1 << 29)
};

struct ConVarInfo {
	explicit ConVarInfo(plg::string name, plg::string description = {});
	~ConVarInfo() = default;

	plg::string name;
	plg::string description;
	std::unique_ptr<ConVarRef> conVar;
	ListenerManager<ConVarChangeListenerCallback> hook;
};

class ConVarManager;
extern ConVarManager g_ConVarManager;

using ConVarInfoPtr = std::unique_ptr<ConVarInfo>;

class ConVarManager {
public:
	ConVarManager() = default;
	~ConVarManager();

	template<typename T>
	ConVarRef CreateConVar(const plg::string& name, const plg::string& description, const T& defaultVal, ConVarFlag flags, bool hasMin = false, T min = {}, bool hasMax = {}, T max = {}) {
		std::scoped_lock lock(m_registerCnvLock);

		if (name.empty() || g_pCVar->FindConVar(name.c_str()).IsValidRef()) {
			return {};
		}

		auto it = m_cnvLookup.find(name);
		if (it != m_cnvLookup.end()) {
			return *std::get<ConVarInfoPtr>(*it)->conVar;
		}

		auto& conVarInfo = *m_cnvLookup.emplace(name, std::make_unique<ConVarInfo>(name, description)).first->second;
		auto conVar = std::make_unique<ConVarRef>(name.c_str());
		if (conVar->IsValidRef()) {
			conVarInfo.conVar = std::move(conVar);
		} else {
			conVarInfo.conVar = std::unique_ptr<ConVarRef>(new CConVar<T>(conVarInfo.name.c_str(), flags, conVarInfo.description.c_str(), defaultVal, hasMin, min, hasMax, max, &ChangeCallback));
		}
		m_cnvCache.emplace(conVarInfo.conVar.get(), &conVarInfo);
		return *conVarInfo.conVar;
	}

	template<typename T>
	ConVarRef FindConVar(const plg::string& name) {
		std::scoped_lock lock(m_registerCnvLock);

		auto it = m_cnvLookup.find(name);
		if (it != m_cnvLookup.end()) {
			return *std::get<ConVarInfoPtr>(*it)->conVar;
		}

		auto& conVarInfo = *m_cnvLookup.emplace(name, std::make_unique<ConVarInfo>(name, "")).first->second;
		conVarInfo.conVar = std::make_unique<CConVarRef<T>>(name.c_str());
		m_cnvCache.emplace(conVarInfo.conVar.get(), &conVarInfo);

		if (!conVarInfo.conVar->IsValidRef()) {
			S2_LOGF(LS_WARNING, "Failed to find \"{}\" convar\n", name);
			return {};
		}

		return *conVarInfo.conVar;
	}

	ConVarRef FindConVar(const plg::string& name);
	bool RemoveConVar(const plg::string& name);

	void HookConVarChange(const plg::string& name, ConVarChangeListenerCallback callback);
	void UnhookConVarChange(const plg::string& name, ConVarChangeListenerCallback callback);

	template<typename T>
	static void ChangeCallback(CConVar<T>* ref, const CSplitScreenSlot slot, const T* pNewValue, const T* pOldValue) {
		auto it = g_ConVarManager.m_cnvCache.find(ref);
		if (it == g_ConVarManager.m_cnvCache.end())
			return;

		auto& conVarInfo = *it->second;

		if constexpr (std::is_same_v<T, bool>) {
			conVarInfo.hook.Notify(*ref, *pNewValue ? "true" : "false", *pOldValue ? "true" : "false");
		} else if constexpr (std::is_same_v<T, CUtlString>) {
			conVarInfo.hook.Notify(*ref, pNewValue->Get(), pOldValue->Get());
		} else if constexpr (std::is_same_v<T, Color>) {
			plg::string newValue = std::format("{} {} {} {}", pNewValue->r(), pNewValue->g(), pNewValue->b(), pNewValue->a());
			plg::string oldValue = std::format("{} {} {} {}", pOldValue->r(), pOldValue->g(), pOldValue->b(), pOldValue->a());
			conVarInfo.hook.Notify(*ref, newValue, oldValue);
		} else if constexpr (std::is_same_v<T, Vector2D>) {
			plg::string newValue = std::format("{} {}", pNewValue->x, pNewValue->y);
			plg::string oldValue = std::format("{} {}", pOldValue->x, pOldValue->y);
			conVarInfo.hook.Notify(*ref, newValue, oldValue);
		} else if constexpr (std::is_same_v<T, Vector> || std::is_same_v<T, QAngle>) {
			plg::string newValue = std::format("{} {} {}", pNewValue->x, pNewValue->y, pNewValue->z);
			plg::string oldValue = std::format("{} {} {}", pOldValue->x, pOldValue->y, pOldValue->z);
			conVarInfo.hook.Notify(*ref, newValue, oldValue);
		} else if constexpr (std::is_same_v<T, Vector4D>) {
			plg::string newValue = std::format("{} {} {} {}", pNewValue->x, pNewValue->y, pNewValue->z, pNewValue->w);
			plg::string oldValue = std::format("{} {} {} {}", pOldValue->x, pOldValue->y, pOldValue->z, pOldValue->w);
			conVarInfo.hook.Notify(*ref, newValue, oldValue);
		} else {
			conVarInfo.hook.Notify(*ref, plg::to_string(*pNewValue), plg::to_string(*pOldValue));
		}
	}

	static void ChangeGlobal(ConVarRefAbstract* ref, CSplitScreenSlot slot, const char* pNewValue, const char* pOldValue, void*);

private:
	std::unordered_map<plg::string, ConVarInfoPtr, plg::case_insensitive_hash, plg::case_insensitive_equal> m_cnvLookup;
	plg::flat_map<const ConVarRef*, const ConVarInfo*> m_cnvCache;
	ListenerManager<ConVarChangeListenerCallback> m_global;
	std::mutex m_registerCnvLock;
};