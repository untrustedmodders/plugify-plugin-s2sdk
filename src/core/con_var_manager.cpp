#include "con_var_manager.hpp"

ConVarManager::~ConVarManager() {
	if (!g_pCVar) {
		return;
	}

	g_pCVar->RemoveGlobalChangeCallback(&ChangeGlobal);
	for (const auto& [cv, _]: m_cnvCache) {
		g_pCVar->UnregisterConVarCallbacks(*cv);
	}
}

ConVarInfo::ConVarInfo(plg::string name, plg::string description) : name(std::move(name)), description(std::move(description)) {
}

bool ConVarManager::RemoveConVar(const plg::string& name) {
	auto it = m_cnvLookup.find(name);
	if (it != m_cnvLookup.end()) {
		m_cnvCache.erase(std::get<ConVarInfoPtr>(*it)->conVar.get());
		m_cnvLookup.erase(it);
		return true;
	}

	return false;
}

ConVarRef ConVarManager::FindConVar(const plg::string& name) {
	auto it = m_cnvLookup.find(name);
	if (it != m_cnvLookup.end()) {
		return *std::get<ConVarInfoPtr>(*it)->conVar;
	}

	auto& conVarInfo = *m_cnvLookup.emplace(name, std::make_unique<ConVarInfo>(name, "")).first->second;
	conVarInfo.conVar = std::make_unique<ConVarRefAbstract>(name.c_str(), true);
	m_cnvCache.emplace(conVarInfo.conVar.get(), &conVarInfo);

	if (!conVarInfo.conVar->IsValidRef()) {
		S2_LOGF(LS_WARNING, "Failed to find \"{}\" convar\n", name);
		return {};
	}

	return *conVarInfo.conVar;
}

void ConVarManager::HookConVarChange(const plg::string& name, ConVarChangeListenerCallback callback) {
	if (name.empty()) {
		if (m_global.Empty()) {
			g_pCVar->InstallGlobalChangeCallback(&ChangeGlobal);
		}
		m_global.Register(callback);
		return;
	}

	auto it = m_cnvLookup.find(name);
	if (it != m_cnvLookup.end()) {
		auto& conVarInfo = *std::get<ConVarInfoPtr>(*it);
		conVarInfo.hook.Register(callback);
	}
}

void ConVarManager::UnhookConVarChange(const plg::string& name, ConVarChangeListenerCallback callback) {
	if (name.empty()) {
		m_global.Unregister(callback);
		if (m_global.Empty()) {
			g_pCVar->RemoveGlobalChangeCallback(&ChangeGlobal);
		}
		return;
	}

	auto it = m_cnvLookup.find(name);
	if (it != m_cnvLookup.end()) {
		auto& conVarInfo = *std::get<ConVarInfoPtr>(*it);
		conVarInfo.hook.Unregister(callback);
	}
}

void ConVarManager::ChangeGlobal(ConVarRefAbstract* ref, CSplitScreenSlot slot, const char* pNewValue, const char* pOldValue, void*) {
	g_ConVarManager.m_global.Notify(*ref, pNewValue, pOldValue);
}

struct ConVar {
	ConVarRef ref;
	ConVarData* data;
};

class ConVarConfigGenerator {
public:
    static std::string FormatConVarData(const ConVarData* conVarData) {
        std::string result;
    	result.reserve(2048);

    	auto it = std::back_inserter(result);

        if (conVarData->HasHelpText()) {
            auto lines = utils::SplitString(conVarData->GetHelpText(), "\n");
            for (const auto& line : lines) {
                std::format_to(it, "// {}\n", line);
            }
        }

        result += "// -\n";

    	CBufferStringN<2048> buffer;

    	if (conVarData->HasDefaultValue()) {
    		conVarData->DefaultValueToString(buffer);
			std::format_to(it, "// Default: \"{}\"\n", buffer.Get());

    	}
        if (conVarData->HasMinValue()) {
    		conVarData->MinValueToString(buffer);
            std::format_to(it, "// Minimum: \"{}\"\n", buffer.Get());

        }
        if (conVarData->HasMaxValue()) {
    		conVarData->MaxValueToString(buffer);
            std::format_to(it, "// Maximum: \"{}\"\n", buffer.Get());
        }

    	conVarData->ValueToString(-1, buffer);
        std::format_to(it, "{} \"{}\"\n\n", conVarData->GetName(), buffer.Get());

        return result;
    }

    static std::string GenerateHeader(std::string_view name) {
        auto now = std::chrono::system_clock::now();
        return std::format(
            "// This file was auto-generated by Plugify (v" S2SDK_VERSION ")\n"
            "// ConVars for plugin \"{}\"\n"
            "// Generated: {:%Y-%m-%d %H:%M:%S}\n\n",
            name, now
        );
    }

    static std::expected<ConVar, std::string> ExtractConVar(uint64 conVarHandle) {
        ConVarRef conVarRef(conVarHandle);

        if (!conVarRef.IsValidRef()) {
            return std::unexpected(std::format("Invalid convar handle: {}", conVarHandle));
        }

        auto* conVarData = g_pCVar->GetConVarData(conVarRef);
        if (conVarData == nullptr) {
            return std::unexpected(std::format("Failed to get ConVar data for handle: {}", conVarHandle));
        }

        return ConVar{ conVarRef, conVarData };
    }
};

class ConVarConfigParser {
public:
	using ConVarMap = std::map<std::string, std::string, plg::case_insensitive_equal>;

	static std::expected<ConVarMap, std::string> ParseConfigFile(const fs::path& filePath) {
		std::error_code ec;
		if (!fs::exists(filePath, ec)) {
			return std::unexpected("Config file does not exist");
		}

		std::ifstream file(filePath);
		if (!file.is_open()) {
			return std::unexpected(std::format("Failed to open config file: {}", plg::as_string(filePath)));
		}

		ConVarMap conVars;
		std::string line;

		while (std::getline(file, line)) {
			std::string_view buffer = Trim(line);

			if (buffer.empty() || buffer.starts_with("//")) {
				continue;
			}

			auto spacePos = buffer.find(' ');
			if (spacePos == std::string::npos) {
				continue;
			}

			std::string_view name = buffer.substr(0, spacePos);
			std::string_view value = Trim(buffer.substr(spacePos + 1));

			if (value.starts_with('"') && value.ends_with('"') && value.length() >= 2) {
				value = value.substr(1, value.length() - 2);
			}

			conVars[std::string(name)] = value;
		}

		return conVars;
	}

private:
	static std::string_view Trim(std::string_view str) noexcept {
		const auto start = str.find_first_not_of(" \t\n\r\f\v");
		if (start == std::string_view::npos)
			return {};
		const auto end = str.find_last_not_of(" \t\n\r\f\v");
		return str.substr(start, end - start + 1);
	}
};

bool ConVarManager::AutoExecConfig(std::span<const uint64> conVarHandles, bool autoCreate, std::string_view name, std::string_view folder) {
    if (name.empty()) {
    	S2_LOGF(LS_WARNING, "No valid Config's name to process\n");
	    return false;
    }

    std::string_view configFolder = folder.empty() ? "plugify" : folder;
    fs::path configPath = utils::GameDirectory() / "cfg" / configFolder;
    fs::path fullPath = configPath / std::format("{}.cfg", name);

    std::vector<ConVar> conVarInfos;
    conVarInfos.reserve(conVarHandles.size());

    for (const auto& handle : conVarHandles) {
		if (auto result = ConVarConfigGenerator::ExtractConVar(handle)) {
            conVarInfos.push_back(std::move(*result));
        } else {
            S2_LOGF(LS_WARNING, "{}\n", result.error());
        }
    }

    if (conVarInfos.empty()) {
        S2_LOGF(LS_WARNING, "No valid ConVars to process\n");
    	return false;
    }

	std::error_code ec;
    bool configExists = fs::exists(fullPath, ec);

    if (configExists) {
        if (auto parseResult = ConVarConfigParser::ParseConfigFile(fullPath)) {
        	for (const auto& [ref, data] : conVarInfos) {
        		std::string label = data->GetName();
                auto it = parseResult->find(label);
                if (it != parseResult->end()) {
            		ConVarRefAbstract conVar(ref, data);
                    UpdateConVarValue(conVar, it->second);
                    S2_LOGF(LS_DEBUG, "Loaded ConVar: {} = \"{}\"\n", label, it->second);
                }
            }
    		S2_LOGF(LS_DEBUG, "Parsed config file: {}\n", plg::as_string(fullPath));
        	return true;
        } else {
            S2_LOGF(LS_WARNING, "Failed to parse config file: {}\n", parseResult.error());
        	return false;
        }
    } else if (autoCreate) {
    	if (!fs::exists(configPath, ec)) {
    		fs::create_directories(configPath, ec);
    	}

    	std::ofstream file(fullPath);
    	if (file.is_open()) {
    		file << ConVarConfigGenerator::GenerateHeader(name);
    		for (const auto& [ref, data] : conVarInfos) {
    			file << ConVarConfigGenerator::FormatConVarData(data);
    		}
    		file.close();
    		S2_LOGF(LS_DEBUG, "Created config file: {}\n", plg::as_string(fullPath));
			return true;
    	} else {
    		S2_LOGF(LS_WARNING, "Failed to create config file: {}\n", plg::as_string(fullPath));
			return false;
    	}
    } else {
        S2_LOGF(LS_WARNING, "Config file does not exist and autoCreate is false: {}\n", plg::as_string(fullPath));
		return false;
    }
}

void ConVarManager::UpdateConVarValue(
    const ConVarRefAbstract& conVar,
	std::string_view value
) {
	bool notify = conVar.GetFlags() & FCVAR_NOTIFY;
	bool replicate = conVar.GetFlags() & FCVAR_REPLICATED;
	switch (EConVarType type = conVar.GetType()) {
		case EConVarType_Bool: {
			using namespace std::string_view_literals;
			plg::case_insensitive_equal eq;
			bool boolean = eq(value, "1"sv) || eq(value, "true"sv) || eq(value, "yes"sv) || eq(value, "on"sv);
			utils::SetConVar(conVar, boolean, replicate, notify);
			break;
		}

		case EConVarType_Int16: {
			if (const auto number = utils::StringToNumber<int16_t>(value)) {
				utils::SetConVar(conVar, *number, replicate, notify);
			} else {
				S2_LOGF(LS_WARNING, "Failed to parse Int16 value for ConVar '{}': '{}' is not a valid integer (range: {} to {})\n",
						conVar.GetName(), value, std::numeric_limits<int16_t>::min(), std::numeric_limits<int16_t>::max());
			}
			break;
		}

		case EConVarType_UInt16: {
			if (const auto number = utils::StringToNumber<uint16_t>(value)) {
				utils::SetConVar(conVar, *number, replicate, notify);
			} else {
				S2_LOGF(LS_WARNING, "Failed to parse UInt16 value for ConVar '{}': '{}' is not a valid unsigned integer (range: 0 to {})\n",
						conVar.GetName(), value, std::numeric_limits<uint16_t>::max());
			}
			break;
		}

		case EConVarType_Int32: {
			if (const auto number = utils::StringToNumber<int32_t>(value)) {
				utils::SetConVar(conVar, *number, replicate, notify);
			} else {
				S2_LOGF(LS_WARNING, "Failed to parse Int32 value for ConVar '{}': '{}' is not a valid integer (range: {} to {})\n",
					   conVar.GetName(), value, std::numeric_limits<int32_t>::min(), std::numeric_limits<int32_t>::max());
			}
			break;
		}

		case EConVarType_UInt32: {
			if (const auto number = utils::StringToNumber<uint32_t>(value)) {
				utils::SetConVar(conVar, *number, replicate, notify);
			} else {
				S2_LOGF(LS_WARNING, "Failed to parse UInt32 value for ConVar '{}': '{}' is not a valid unsigned integer (range: 0 to {})\n",
						conVar.GetName(), value, std::numeric_limits<uint32_t>::max());
			}
			break;
		}

		case EConVarType_Int64: {
			if (const auto number = utils::StringToNumber<int64_t>(value)) {
				utils::SetConVar(conVar, *number, replicate, notify);
			} else {
				S2_LOGF(LS_WARNING, "Failed to parse Int64 value for ConVar '{}': '{}' is not a valid integer (range: {} to {})\n",
						conVar.GetName(), value, std::numeric_limits<int64_t>::min(), std::numeric_limits<int64_t>::max());
			}
			break;
		}

		case EConVarType_UInt64: {
			if (const auto number = utils::StringToNumber<uint64_t>(value)) {
				utils::SetConVar(conVar, *number, replicate, notify);
			} else {
				S2_LOGF(LS_WARNING, "Failed to parse UInt64 value for ConVar '{}': '{}' is not a valid unsigned integer (range: 0 to {})\n",
						conVar.GetName(), value, std::numeric_limits<uint64_t>::max());
			}
			break;
		}

		case EConVarType_Float32: {
			if (const auto number = utils::StringToNumber<float>(value)) {
				utils::SetConVar(conVar, *number, replicate, notify);
			} else {
				S2_LOGF(LS_WARNING, "Failed to parse Float32 value for ConVar '{}': '{}' is not a valid floating-point number\n",
						conVar.GetName(), value);
			}
			break;
		}

		case EConVarType_Float64: {
			const auto number = utils::StringToNumber<double>(value);
			if (number) {
				utils::SetConVar(conVar, *number, replicate, notify);
			} else {
				S2_LOGF(LS_WARNING, "Failed to parse Float64 value for ConVar '{}': '{}' is not a valid floating-point number\n",
						conVar.GetName(), value);
			}
			break;
		}

		case EConVarType_String: {
			utils::SetConVar(conVar, CUtlString(value.data(), static_cast<int>(value.size())), replicate, notify);
			break;
		}

		case EConVarType_Color: {
			const auto color = utils::StringToVector<int>(value);
			if (color.size() == 4) {
				utils::SetConVar(conVar, Color(color[0], color[1], color[2], color[3]), replicate, notify);
			} else {
				S2_LOGF(LS_WARNING, "Invalid Color value for ConVar '{}': expected 4 components, got {}. Value: '{}'\n",
						conVar.GetName(), color.size(), value);
			}
			break;
		}

		case EConVarType_Vector2: {
			if (const auto vector = utils::StringToVector<float>(value); vector.size() == 2) {
				utils::SetConVar(conVar, Vector2D(vector[0], vector[1]), replicate, notify);
			} else {
				S2_LOGF(LS_WARNING, "Invalid Vector2D value for ConVar '{}': expected 2 components, got {}. Value: '{}'\n",
						conVar.GetName(), vector.size(), value);
			}
			break;
		}

		case EConVarType_Vector3: {
			if (const auto vector = utils::StringToVector<float>(value); vector.size() == 3) {
				utils::SetConVar(conVar, Vector(vector[0], vector[1], vector[2]), replicate, notify);
			} else {
				S2_LOGF(LS_WARNING, "Invalid Vector3 value for ConVar '{}': expected 3 components, got {}. Value: '{}'\n",
						conVar.GetName(), vector.size(), value);
			}
			break;
		}

		case EConVarType_Vector4: {
			if (const auto vector = utils::StringToVector<float>(value); vector.size() == 4) {
				utils::SetConVar(conVar, Vector4D(vector[0], vector[1], vector[2], vector[3]), replicate, notify);
			} else {
				S2_LOGF(LS_WARNING, "Invalid Vector4D value for ConVar '{}': expected 4 components, got {}. Value: '{}'\n",
						conVar.GetName(), vector.size(), value);
			}
			break;
		}

		case EConVarType_Qangle: {
			if (const auto vector = utils::StringToVector<float>(value); vector.size() == 3) {
				utils::SetConVar(conVar, QAngle(vector[0], vector[1], vector[2]), replicate, notify);
			} else {
				S2_LOGF(LS_WARNING, "Invalid QAngle value for ConVar '{}': expected 3 components (pitch, yaw, roll), got {}. Value: '{}'\n",
						conVar.GetName(), vector.size(), value);
			}
			break;
		}

		default:
			S2_LOGF(LS_WARNING, "Invalid convar type: {}\n", static_cast<int>(type));
			break;
	}
}

ConVarManager g_ConVarManager;